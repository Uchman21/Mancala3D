using UnityEngine;
using UnityEngine.UI;
using System.Collections;
using UnityEngine.Networking;

public class Player : NetworkBehaviour {
	private GameObject[] Arrays;
	private GameObject[] Cstones;
	private GameObject pholes;

	public Text player1Seed;
	//[SyncVar]
	public Text player2Seed; 

	private GUIS info;
	private int getarea;
	//[SyncVar]
	private int DrawCount =1; 
	//[SyncVar]
	public float timer=0f;
	private int levels;
	//[SyncVar]
	//private int boxmax=0;

	[SyncVar]
	public bool waiting=false;
	public bool wait=false;
	public bool finalwait=true;
	public bool FRound=false;

	public string selection=null;
	public Color color;
	private int cl=0;
	public string current=null;
	public string previous=null;
	private handprefabhelper phand;
	private movehandprefab hand;
	[SyncVar]
	private Animator handAnimation;
	private Animator handAnimation2;
	public string theplayer;
	public Rigidbody p1winhole;
	public Rigidbody p2winhole;
	public Vector3 origin;
	[SyncVar]
	bool addwstone = true;
	[SyncVar]
	public int addrequests =0;
	//private int choice;
	//public Color color;


	// Use this for initialization
	void Start () {
//		WonHoles= FindObjectsOfType(typeof(WonStones))as WonStones[];
//		Fill= FindObjectsOfType(typeof(Win1))as Win1[];
		info = FindObjectOfType (typeof(GUIS))as GUIS;
		phand = FindObjectOfType (typeof(handprefabhelper))as handprefabhelper;
		handAnimation2 = phand.rb2D.GetComponent<Animator>();
		//handAnimation = hand.rb2D.GetComponent<Animator> ();
		phand.handpoly.enabled = false;
		//choice = SceneManager.choice;
	
	}


	public void NewGame(ref int []A,ref int []SeedsWon)                //new game - put 4 pearls in each hole 2 x 6 
	{
		hand = FindObjectOfType (typeof(movehandprefab))as movehandprefab;
		origin = hand.startPoint.transform.position;
		for(int i=0; i<12;i++)
		{
			A[i]=4;
		
		}
		for(int i=0; i<2;i++)
		{
			SeedsWon[i]=0;
			
		}
	}

	IEnumerator clearhole(int Gbox, int type)
	{
		int i=0;
		Cstones = GameObject.FindGameObjectsWithTag("stone"+(Gbox+1));
		pholes = GameObject.FindGameObjectWithTag("points"+(Gbox+1));
		if (type == 0) {
			phand.handpoly.enabled = true;
			yield return StartCoroutine (phand.JMove ((int)pholes.transform.position.x, (int)pholes.transform.position.y, (int)pholes.transform.position.z));
			handAnimation2.SetTrigger ("grab");
		} else {
			yield return StartCoroutine (hand.JMove ((int)pholes.transform.position.x, (int)pholes.transform.position.y, (int)pholes.transform.position.z));
			handAnimation.SetTrigger ("grab");
		}
		while(i<Cstones.Length){    //clear the hole
			Destroy(Cstones[i].gameObject);
			i+=1;
		}
	}

	


	IEnumerator ShowMessage (string message, float delay) {
		info.GetComponent<GUIText>().text = message;
		info.GetComponent<GUIText>().enabled = true;
		yield return new WaitForSeconds(delay);
		info.GetComponent<GUIText>().enabled = false;
	}

	
	IEnumerator Addhole(int Gbox)
	{
		pholes = GameObject.FindGameObjectWithTag("points"+(Gbox+1));
		handAnimation.SetTrigger("share");
		yield return StartCoroutine(hand.JMove ((int)pholes.transform.position.x, (int)pholes.transform.position.y, (int)pholes.transform.position.z));
		hand.Cmdshoot (1f, (Gbox+1));
		yield return new WaitForSeconds(0.3f);
	}

	IEnumerator AddWonStones (int type, int hole) {
		addrequests++;
		while(addwstone==false){yield return new WaitForSeconds(0.3f);}
		addwstone = false;
		Vector3 winpos;
		if (hole == 0) {
			winpos = p1winhole.transform.position;
		} else {
			winpos = p2winhole.transform.position;
		}
		if (type == 0) {
			phand.handpoly.enabled = true;
			yield return StartCoroutine (phand.JMove ((int)winpos.x, (int)winpos.y, (int)winpos.z));
			yield return StartCoroutine (shooter (0, 14));
			addrequests--;
			if(addrequests < 1){
				yield return StartCoroutine (phand.JMove ((int)origin.x, (int)origin.y, (int)origin.z));
				phand.handpoly.enabled=false;
			}
		} else {
			yield return StartCoroutine (hand.JMove ((int)winpos.x, (int)winpos.y, (int)winpos.z));
			yield return StartCoroutine (shooter (1, 14));
			addrequests--;
			if(addrequests < 1){
				yield return StartCoroutine (hand.JMove ((int)origin.x, (int)origin.y, (int)origin.z));
				phand.handpoly.enabled=false;
			}
		}

		addwstone = true;

	}

	IEnumerator shooter(int type, int label){
		int counter = 0;
		while (counter < 4) {
			if (type == 0) {
				phand.Cmdshoot (0.0005f, label);
			} else {
				hand.Cmdshoot (0.0005f, label);
			}
			timer = 0.0f;
			counter = counter + 1;
			yield return new WaitForSeconds (0.1f);		
		}
	}

	public int AddGame(int []A)                //add game -check to  put 8 pearls in hole at last round 
	{
		int add=0;
			for(int i=0; i<12;i++)
			{
				add+=A[i];
			}
		return add;
	}

	IEnumerator EmptyHoles(int []A, int type)                //remove all seeds
	{
		for(int i=0; i<12;i++)
		{
			if(A[i]>0){
				yield return StartCoroutine(clearhole(i,type));
			}
			
			A[i]=0;
		}
		yield return null;
		
	}
		
	void updateScore(ref int player,ref int []SeedsWon){
		if (player == 0) {
			player1Seed.text = "X" + SeedsWon [0].ToString ();
		} else {
			player2Seed.text = "X" + SeedsWon [1].ToString ();
		}
	}
	IEnumerator Analize(int [] A, int []SeedsWon,int SIB,int owner, int box,int fseed)   //check the seeds in the box after a play. if up to four, the owner of the area takes it. SIB - Seeds In the Box
	{
		if(SIB == 4 && fseed != 1)
		{
			SeedsWon[owner] +=4;
			yield return new WaitForSeconds(0.1f);
			//updateWonhole=true;
			yield return StartCoroutine(clearhole(box,0));
			A[box]=0;
			StartCoroutine(AddWonStones(0,owner));  // Add the stones won
			updateScore(ref owner,ref SeedsWon);
			if(AddGame(A)==4)  // If only 8 seeds are remaining on the board, take all
			{
				SeedsWon[owner] +=4;
				updateScore(ref owner,ref SeedsWon);
				yield return StartCoroutine(EmptyHoles(A,1));
				yield return StartCoroutine(AddWonStones(1,owner));
				FRound=true;
			}
		}
		yield return null;

	}

public IEnumerator GamePlay(int player, int box, int []GameHoles, int []SeedsWon, int []OwnedHoles)     
		
	{
		finalwait=false;
		int seeds,owner;
		seeds = GameHoles[box];
		GameHoles[box]=0;
		yield return StartCoroutine(clearhole(box,1));
		while(true)
		{
			box++;
			if (box > 11){
				box = 0;
			}
			GameHoles[box] +=1;
			yield return StartCoroutine( Addhole(box));
			if(box < OwnedHoles[0]){
				owner = 0;
			}else{
				owner = 1;
			}
			yield return StartCoroutine( Analize(GameHoles,SeedsWon,GameHoles[box],owner,box,seeds));
			if (FRound == true)goto end1;
			FRound=false;
			seeds--;
			if(seeds == 0 && (GameHoles[box] > 1 && GameHoles[box] !=4))
			{
				cl++;
				if (cl>40)goto end1;
				seeds = GameHoles[box];
				GameHoles[box] =0;
				yield return StartCoroutine(clearhole(box,1));
			}else if(GameHoles[box]==4){
				SeedsWon[player] +=4;
				updateScore(ref player,ref SeedsWon);
				GameHoles[box]=0;
				yield return StartCoroutine(clearhole(box,1));
				yield return StartCoroutine(AddWonStones(player,1));
				if(AddGame(GameHoles)==4)  // If only 8 seeds are remaining on the board, take all
				{
					SeedsWon[player] +=4;
					updateScore(ref player,ref SeedsWon);
					yield return StartCoroutine(EmptyHoles(GameHoles,1));
					yield return StartCoroutine(AddWonStones(player,1));
				}
				break;
			}else if (seeds == 0){
				break;
			}
		}

	end1:
			cl=0;
			finalwait=true;
			handAnimation.SetTrigger("open");
			yield return StartCoroutine( hand.JMove ((int)origin.x, (int)origin.y, (int)origin.z));

	}

	public int CheckGame(int player,ref int []SeedsWon)  // check if draw, win or lose
	{
		if((SeedsWon[0] + SeedsWon[1])>=40)
		{
			if(((SeedsWon[0] + SeedsWon[1]) == 40 ))    //Max number of times to be considered before the game ends =10
			{
				DrawCount++;
				if (DrawCount >= 10) return 10;
				
			}else if((SeedsWon[0] + SeedsWon[1]) > 40 && (SeedsWon[player] > SeedsWon[(player+1)%2]))   // If Player has higher seeds
			{
				return 1;
			}else if((SeedsWon[0] + SeedsWon[1]) > 40 && (SeedsWon[(player+1)%2] == SeedsWon[player]))  // If Opponent has higher seeds
			{
				return 0;
			}
		}

		return 2;
	}
	
public	bool CanPlay(int player,ref int []GameHoles,ref int []phouse)
	{
		if (player == 0) {
			for(int i = 0; i< phouse[0]; i++){
				if(GameHoles[i] != 0){
					return true;
				}
			}

		} else {
			for(int i = phouse[0]; i < 12; i++){
				if(GameHoles[i] != 0){
					return true;
				}
			}
		}
		return false;
	}

	bool Possible(int column,int []A)
	{
		if(A[column] >0)
		{
			return true;
		}else{
			return false;
		}
	}

	void copyGameHoles(ref int []from,ref int []to)
	{
		for(int i=0; i<12;i++)
		{
			to[i] = from[i];
		}
	}

	void copyWonSeeds(ref int []from,ref int []to)
	{
		for(int i=0; i<2;i++)
		{
			to[i]=from[i];
		}
	}



	int EndCheck(int x, int y)
	{

		if((x+y)>=40){
			 if ((x-y)>=0)return -40;
		}
		return x-y;
		
	}
		
	

	// Update is called once per frame
	void Update () {
	}
}
